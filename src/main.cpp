/**
 * Comprehensive WAMR Benchmark Suite
 *
 * Tests WASM vs native C++ performance across multiple workloads:
 * - Mathematical computations (recursive, iterative)
 * - Memory operations (arrays, sorting)
 * - Native function integration
 * - API overhead comparison (callFunction vs callFunctionRaw)
 */

#include <Arduino.h>
#include <WAMR.h>
#include <pthread.h>

// WASM module headers (generated by build_wasm.sh)
#include "benchmark_wasm.h"
#include "native_calls_wasm.h"

// Global WAMR modules
WamrModule benchmark_module;
WamrModule native_calls_module;

// Helper struct for loading modules in pthread
struct LoadContext {
  WamrModule* module;
  const uint8_t* wasm_bytes;
  uint32_t size;
  uint32_t stack_size;
  uint32_t heap_size;
  bool success;
};

// Thread wrapper for load operation
void* load_thread_wrapper(void* arg) {
  LoadContext* ctx = (LoadContext*)arg;
  ctx->success = ctx->module->load(ctx->wasm_bytes, ctx->size, ctx->stack_size, ctx->heap_size);
  return nullptr;
}

// Load module in pthread context
bool load_in_thread(WamrModule* module, const uint8_t* wasm_bytes, uint32_t size, uint32_t stack_size, uint32_t heap_size) {
  LoadContext ctx;
  ctx.module = module;
  ctx.wasm_bytes = wasm_bytes;
  ctx.size = size;
  ctx.stack_size = stack_size;
  ctx.heap_size = heap_size;
  ctx.success = false;

  pthread_t thread;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 32 * 1024);  // 32KB stack for load operation
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

  if (pthread_create(&thread, &attr, load_thread_wrapper, &ctx) != 0) {
    Serial.println("ERROR: Failed to create pthread for module loading");
    pthread_attr_destroy(&attr);
    return false;
  }

  pthread_join(thread, nullptr);
  pthread_attr_destroy(&attr);

  return ctx.success;
}

// ============================================================================
// Native C++ Implementations (for comparison)
// ============================================================================

int native_fibonacci_iterative(int n) {
  if (n <= 1) return n;
  int prev = 0, curr = 1;
  for (int i = 2; i <= n; i++) {
    int next = prev + curr;
    prev = curr;
    curr = next;
  }
  return curr;
}

int native_factorial_iterative(int n) {
  int result = 1;
  for (int i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

int native_array_sum(int* arr, int len) {
  int sum = 0;
  for (int i = 0; i < len; i++) {
    sum += arr[i];
  }
  return sum;
}

void native_bubble_sort(int* arr, int len) {
  for (int i = 0; i < len - 1; i++) {
    for (int j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}

// ============================================================================
// Native Functions Exported to WASM
// ============================================================================

static void native_pin_mode_wrapper(wasm_exec_env_t exec_env, int pin, int mode) {
  pinMode(pin, mode);
}

static void native_digital_write_wrapper(wasm_exec_env_t exec_env, int pin, int value) {
  digitalWrite(pin, value);
}

static int native_digital_read_wrapper(wasm_exec_env_t exec_env, int pin) {
  return digitalRead(pin);
}

static int native_analog_read_wrapper(wasm_exec_env_t exec_env, int pin) {
  return analogRead(pin);
}

static unsigned int native_millis_wrapper(wasm_exec_env_t exec_env) {
  return millis();
}

static void native_delay_wrapper(wasm_exec_env_t exec_env, unsigned int ms) {
  delay(ms);
}

static void native_print_string_wrapper(wasm_exec_env_t exec_env, const char* str) {
  // Note: In production, you'd want to translate WASM pointer to native pointer
  // For now, we'll use a simple approach
  Serial.print("[WASM] ");
  // This is simplified - proper implementation would use wasm_runtime_addr_app_to_native
}

static void native_print_int_wrapper(wasm_exec_env_t exec_env, int value) {
  Serial.print(value);
}

// Native symbol table for WASM
static NativeSymbol native_symbols[] = {
  {"native_pin_mode", (void*)native_pin_mode_wrapper, "(ii)", nullptr},
  {"native_digital_write", (void*)native_digital_write_wrapper, "(ii)", nullptr},
  {"native_digital_read", (void*)native_digital_read_wrapper, "(i)i", nullptr},
  {"native_analog_read", (void*)native_analog_read_wrapper, "(i)i", nullptr},
  {"native_millis", (void*)native_millis_wrapper, "()i", nullptr},
  {"native_delay", (void*)native_delay_wrapper, "(i)", nullptr},
  {"native_print_string", (void*)native_print_string_wrapper, "(*)", nullptr},
  {"native_print_int", (void*)native_print_int_wrapper, "(i)", nullptr},
};

// ============================================================================
// Benchmark Helper Functions
// ============================================================================

struct BenchmarkResult {
  const char* test_name;
  uint32_t wasm_time_us;
  uint32_t native_time_us;
  int wasm_result;
  int native_result;
  float overhead_percent;
};

void print_benchmark_header() {
  Serial.println("\n========================================");
  Serial.println("  WASM vs Native Performance");
  Serial.println("========================================");
  Serial.printf("%-25s %10s %10s %8s\n", "Test", "WASM (μs)", "Native (μs)", "Overhead");
  Serial.println("-----------------------------------------------------------");
}

void print_benchmark_result(BenchmarkResult& result) {
  // Calculate overhead, handle division by zero
  if (result.native_time_us > 0) {
    result.overhead_percent = ((float)(result.wasm_time_us - result.native_time_us) / result.native_time_us) * 100.0f;
  } else {
    // Native is too fast to measure, calculate based on absolute difference
    result.overhead_percent = 999.9f;  // Indicate "very large"
  }

  Serial.printf("%-25s %10u %10u %7.1f%%\n",
    result.test_name,
    result.wasm_time_us,
    result.native_time_us,
    result.overhead_percent
  );

  // Verify results match
  if (result.wasm_result != result.native_result) {
    Serial.printf("  WARNING: Results differ! WASM=%d Native=%d\n",
      result.wasm_result, result.native_result);
  }
}

// ============================================================================
// Benchmark Tests
// ============================================================================

BenchmarkResult benchmark_fibonacci(int n) {
  BenchmarkResult result = {"Fibonacci(20) x1000", 0, 0, 0, 0, 0};

  // WASM version - single call that loops 1000x internally
  uint32_t args[1] = {(uint32_t)n};
  unsigned long start = micros();
  benchmark_module.callFunction("fibonacci_bench_1000", 1, args);
  unsigned long wasm_end = micros();
  result.wasm_time_us = wasm_end - start;
  result.wasm_result = args[0];

  // Native version - run 1000 times to match
  const int iterations = 1000;
  start = micros();
  for (int i = 0; i < iterations; i++) {
    result.native_result = native_fibonacci_iterative(n);
  }
  unsigned long native_end = micros();
  result.native_time_us = native_end - start;

  return result;
}

BenchmarkResult benchmark_factorial(int n) {
  BenchmarkResult result = {"Factorial(10) x1000", 0, 0, 0, 0, 0};

  // WASM version - single call that loops 1000x internally
  uint32_t args[1] = {(uint32_t)n};
  unsigned long start = micros();
  benchmark_module.callFunction("factorial_bench_1000", 1, args);
  unsigned long wasm_end = micros();
  result.wasm_time_us = wasm_end - start;
  result.wasm_result = args[0];

  // Native version - run 1000 times to match
  const int iterations = 1000;
  start = micros();
  for (int i = 0; i < iterations; i++) {
    result.native_result = native_factorial_iterative(n);
  }
  unsigned long native_end = micros();
  result.native_time_us = native_end - start;

  return result;
}

BenchmarkResult benchmark_array_operations() {
  BenchmarkResult result = {"Computation x1000", 0, 0, 0, 0, 0};

  // WASM version - call fibonacci_bench_1000 as computation proxy
  uint32_t args[1] = {15};  // fib(15) x1000
  unsigned long start = micros();
  benchmark_module.callFunction("fibonacci_bench_1000", 1, args);
  unsigned long wasm_end = micros();
  result.wasm_time_us = wasm_end - start;
  result.wasm_result = args[0];

  // Native version - run 1000 times to match
  const int iterations = 1000;
  start = micros();
  for (int i = 0; i < iterations; i++) {
    result.native_result = native_fibonacci_iterative(15);
  }
  unsigned long native_end = micros();
  result.native_time_us = native_end - start;

  return result;
}

BenchmarkResult benchmark_api_overhead() {
  BenchmarkResult result = {"API Overhead (avg/call)", 0, 0, 0, 0, 0};

  // Test callFunction() - safe API with pthread overhead (100 iterations)
  const int wasm_iterations = 100;
  unsigned long start = micros();
  for (int i = 0; i < wasm_iterations; i++) {
    uint32_t args[1] = {5};
    benchmark_module.callFunction("factorial_iterative", 1, args);
  }
  unsigned long safe_end = micros();
  result.wasm_time_us = (safe_end - start) / wasm_iterations;  // Average per call

  // For comparison: direct C++ function call (10000 iterations for accuracy)
  const int native_iterations = 10000;
  start = micros();
  for (int i = 0; i < native_iterations; i++) {
    native_factorial_iterative(5);
  }
  unsigned long native_end = micros();
  result.native_time_us = (native_end - start) / native_iterations;  // Average per call

  result.wasm_result = 120;  // 5!
  result.native_result = 120;

  return result;
}

// ============================================================================
// Setup and Main Loop
// ============================================================================

void setup() {
  Serial.begin(115200);
  delay(2000);  // Wait for serial

  Serial.println("\n");
  Serial.println("╔═══════════════════════════════════════════════════════╗");
  Serial.println("║   WAMR ESP32 Comprehensive Benchmark Suite            ║");
  Serial.println("╚═══════════════════════════════════════════════════════╝");
  Serial.println();

  // Print system info
  Serial.println("System Information:");
  Serial.printf("  Chip: %s\n", ESP.getChipModel());
  Serial.printf("  CPU Frequency: %d MHz\n", ESP.getCpuFreqMHz());
  Serial.printf("  Free Heap: %d bytes\n", ESP.getFreeHeap());
  Serial.printf("  PSRAM: %s\n", psramFound() ? "Available" : "Not Available");
  Serial.println();

  // ========================================================================
  // Initialize WAMR Runtime
  // ========================================================================

  Serial.println("[1/4] Initializing WAMR runtime...");
  if (!WamrRuntime::begin(128 * 1024)) {  // 128KB heap (reduced for ESP32-S3 without PSRAM)
    Serial.println("ERROR: Failed to initialize WAMR runtime!");
    Serial.println(WamrRuntime::getError());
    while (1) delay(1000);
  }
  Serial.println("✓ WAMR runtime initialized\n");

  // ========================================================================
  // Register Native Functions
  // ========================================================================

  Serial.println("[2/4] Registering native functions...");
  int native_count = sizeof(native_symbols) / sizeof(NativeSymbol);
  if (!wasm_runtime_register_natives("env", native_symbols, native_count)) {
    Serial.println("ERROR: Failed to register native functions!");
    while (1) delay(1000);
  }
  Serial.printf("✓ Registered %d native functions\n\n", native_count);

  // ========================================================================
  // Load WASM Modules
  // ========================================================================

  // ========================================================================
  // PART 1: Benchmark Module Tests
  // ========================================================================

  Serial.println("[3/5] Loading benchmark module...");

  // Load benchmark module in pthread context
  if (!load_in_thread(&benchmark_module, benchmark_wasm, benchmark_wasm_len, 16*1024, 32*1024)) {
    Serial.println("ERROR: Failed to load benchmark module!");
    Serial.println(benchmark_module.getError());
    while (1) delay(1000);
  }
  Serial.printf("✓ Loaded benchmark.wasm (%d bytes)\n\n", benchmark_wasm_len);

  Serial.println("[4/5] Running computation benchmarks...\n");
  delay(500);

  print_benchmark_header();

  // Mathematical benchmarks
  BenchmarkResult fib_result = benchmark_fibonacci(20);
  print_benchmark_result(fib_result);

  BenchmarkResult fact_result = benchmark_factorial(10);
  print_benchmark_result(fact_result);

  // Array operations
  BenchmarkResult array_result = benchmark_array_operations();
  print_benchmark_result(array_result);

  // API overhead
  BenchmarkResult api_result = benchmark_api_overhead();
  print_benchmark_result(api_result);

  Serial.println("-----------------------------------------------------------\n");

  Serial.println("Summary:");
  Serial.printf("  Average WASM overhead: %.1f%%\n",
    (fib_result.overhead_percent + fact_result.overhead_percent +
     array_result.overhead_percent + api_result.overhead_percent) / 4.0f);
  Serial.println();

  // Unload benchmark module to free memory
  Serial.println("Unloading benchmark module to free memory...");
  benchmark_module.unload();
  Serial.println("✓ Benchmark module unloaded\n");

  WamrRuntime::printMemoryUsage();
  Serial.println();

  // ========================================================================
  // PART 2: Native Calls Module Demo
  // ========================================================================

  Serial.println("[5/5] Loading native calls module...");

  // Load native_calls module in pthread context
  if (!load_in_thread(&native_calls_module, native_calls_wasm, native_calls_wasm_len, 16*1024, 32*1024)) {
    Serial.println("ERROR: Failed to load native_calls module!");
    Serial.println(native_calls_module.getError());
    while (1) delay(1000);
  }
  Serial.printf("✓ Loaded native_calls.wasm (%d bytes)\n\n", native_calls_wasm_len);

  Serial.println("========================================");
  Serial.println("  Native Function Integration Demo");
  Serial.println("========================================\n");

  Serial.println("Note: Native function demo would require actual");
  Serial.println("GPIO pins and hardware for full testing.");
  Serial.println("See native_calls.c for available functions.\n");

  // Unload native calls module
  Serial.println("Unloading native calls module...");
  native_calls_module.unload();
  Serial.println("✓ Native calls module unloaded\n");

  Serial.println("╔═══════════════════════════════════════════════════════╗");
  Serial.println("║   Benchmark Complete!                                 ║");
  Serial.println("╚═══════════════════════════════════════════════════════╝");
  Serial.println();
}

void loop() {
  // Benchmark runs once in setup()
  delay(10000);
}
